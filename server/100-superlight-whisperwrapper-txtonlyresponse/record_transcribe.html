<!DOCTYPE html>
<html>
<body onload="connectWebSocket()" >

  <button id="start">Start</button>
  <button id="stop">Stop</button>
  <br>
  <br>
  <label for="timeInterval">Sound Clip Length (ms):</label>
  <input id="timeInterval" type="number" value="1000"> <!-- Changed to 1000ms -->
  <br>
  <br>
  <label for="chunkCount">Number of Chunks:</label>
  <input id="chunkCount" type="number" value="10"> <!-- New field -->
  <br>
  <br>
  <label for="urlInput">Upload URL:</label>
  <input id="urlInput" type="text" value="https://3llwzi00h3.execute-api.us-east-2.amazonaws.com/test/file-upload">
  <br>
  <br>
  <label for="sequenceInput">Starting Sequence Number:</label>
  <input id="sequenceInput" type="number" value="1">
  <br>
  <br>
  <label for="flaskUrlInput">Flask Upload URL:</label>
  <input id="flaskUrlInput" type="text" value="http://ec2-3-22-47-41.us-east-2.compute.amazonaws.com:8768/upload">
  <br>
  <br>
  <label for="MIN_DECIBELS">MIN_DECIBELS:</label>
  <input id="MIN_DECIBELS" type="text" value="-60"><br>
  <label for="MIN_DECIBELS">Minimum amount of Decibels for silence detection. -100db more Senstive, -10dB less sensitive.</label>
  <br>
  <br>
  <label for="fileFormat">File Format:</label>
  <input type="radio" id="flacFormat" name="fileFormat" value="flac" checked>
  <label for="flacFormat">FLAC</label>
  <input type="radio" id="oggFormat" name="fileFormat" value="ogg">
  <label for="oggFormat">OGG</label>
  <br>
  <br>

  <button id="toggle">Toggle Append Mode</button>
  <p id="appendMode">appendMode: Not Toggled</p>
  <p id="soundDetected">soundDetected: not started</p>
  <br>
  <br>
  <button id="update">Update</button>
  
  <div id="unifiedTableContainer" style="height: 400px; overflow-y: auto;">
    <table id="unifiedTable">
      <thead>
        <tr>
          <th>File Name</th>
          <th>Play</th>
          <th>Transcription</th>
        </tr>
      </thead>
      <tbody id="unifiedTableBody">
        <!-- Rows will be added here dynamically -->
      </tbody>
    </table>
  </div>

 
  
  <script type="text/javascript">
    var ws;
    var heartbeatInterval;

    function scrollToBottom() {
        console.log("Attempting to scroll to the bottom.");  // Debugging statement
        const tableContainer = document.getElementById('tableContainer');
        tableContainer.scrollTop = tableContainer.scrollHeight;
    }
  
    function connectWebSocket() {
        // Connect to WebSocket server
        ws = new WebSocket("ws://3.22.47.41:8766/");
        ws.onopen = function() {
            console.log("Connected to the server");
            
            // Start the heartbeat interval when the connection opens
            heartbeatInterval = setInterval(function() {
                console.log("Sending heartbeat");  // Debugging statement
    
                ws.send(JSON.stringify({'heartbeat': 'ping'}));
            }, 5000); // 5 seconds
        };

        ws.onmessage = function(event) {
            //console.log("Received a message from the server.");  // Debugging statement
        
            // Parse received JSON message
            var data = JSON.parse(event.data);
            //console.log("Parsed data:", data);  // Debugging statement
        
            // Check if this is a heartbeat message
            if (data.heartbeat) {
                console.log("Received a heartbeat message.");  // Debugging statement
                return;
            }
        
            // Extract and parse the 'file_info' content
            if (data.file_info) {
                //console.log("Received 'file_info' key.");  // Debugging statement
        
                var fileInfo = JSON.parse(data.file_info);
                //console.log("Parsed 'file_info':", fileInfo);  // Debugging statement
        
                var filename = fileInfo.filename;
                var transcribedMessage = fileInfo.transcribed_message;
        
                //console.log("Filename:", filename);  // Debugging statement
                //console.log("Transcribed Message:", transcribedMessage);  // Debugging statement
        
                updateUnifiedTable(filename, transcribedMessage, null);
                //console.log("Updated the transcription table.");  // Debugging statement
            } else {
                console.log("Did not receive 'file_info' key.");  // Debugging statement
            }
        };

        ws.onclose = function() {
            console.log("Connection is closed");

            // Clear the heartbeat interval when the connection closes
            clearInterval(heartbeatInterval);
        };
    }

  </script>


  <script>
  // Initialize variables
  let audioBuffer = [];
  let mediaRecorder;
  let intervalId;
  let shouldContinueRecording = false;
  let uploadURL = document.getElementById('urlInput').value;
  let timeInterval = parseInt(document.getElementById('timeInterval').value);
  let sequenceNumber = parseInt(document.getElementById('sequenceInput').value);
  let chunkCount = parseInt(document.getElementById('chunkCount').value);
  let flaskUploadURL = document.getElementById('flaskUrlInput').value;
  let shouldRestart = false; // New variable to handle restarts
  let isMediaRecorderInitialized = false;  // Flag to check if MediaRecorder is initialized
  let db;
  let appendMode = false;
  // New JavaScript code for sound detection
  let soundDetected = false;
  let checkInterval;
  let MIN_DECIBELS = document.getElementById('MIN_DECIBELS').value;
  //const MIN_DECIBELS = -60;  //-100dB makes the setting more senstive so it will consider more sound as noise, vs -10dB you need a louder sound to prevent the silence detected status from being triggered.


  
  function initializeIndexedDB() {
    const request = indexedDB.open("audioDB", 1);
  
    request.onupgradeneeded = function(event) {
      db = event.target.result;
      const objectStore = db.createObjectStore("audioChunks", { autoIncrement: true });
    };
  
    request.onsuccess = function(event) {
      db = event.target.result;
    };
  
    request.onerror = function(event) {
      console.error("IndexedDB error:", event.target.errorCode);
    };
  }
  
  // Call the function to initialize IndexedDB
  initializeIndexedDB();
 
  const generateFileName = () => {
    const date = new Date();
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    const hour = String(date.getHours()).padStart(2, '0');
    const minute = String(date.getMinutes()).padStart(2, '0');
    const sequence = String(sequenceNumber).padStart(6, '0');
    const selectedFormat = document.querySelector('input[name="fileFormat"]:checked').value;
    return `${year}-${month}-${day}-${hour}${minute}-${sequence}.${selectedFormat}`;
  };


  // This function uploads to the LinuxHost, in contrast, of uploading to S3.
  async function uploadToLinuxHost(blob) {
    const fileKey = generateFileName();
    const selectedFormat = document.querySelector('input[name="fileFormat"]:checked').value; // New code
    const formData = new FormData();
    formData.append("file", blob, fileKey);
  
    await fetch(flaskUploadURL, {
      method: 'POST',
      body: formData,
    }).then(response => response.text())  // Added this for debug
      .then(data => console.log("Server Response:", data))  // Debug log
      .catch((error) => console.error("Error:", error));  // Debug log
  }
  
	  
  document.getElementById('update').onclick = () => {
    uploadURL = document.getElementById('urlInput').value;
    timeInterval = parseInt(document.getElementById('timeInterval').value);
    sequenceNumber = parseInt(document.getElementById('sequenceInput').value);
    chunkCount = parseInt(document.getElementById('chunkCount').value); // Update the chunk count from the input
    flaskUploadURL = document.getElementById('flaskUrlInput').value;    // this is the url for the EC2 host / RunPod.io host.
  };
    
  document.getElementById('start').onclick = () => {
    shouldContinueRecording = true;
    startRecording();
  };
  
  const startRecording = () => {
    timeInterval = parseInt(document.getElementById('timeInterval').value);  // Update based on user input
  
    if (isMediaRecorderInitialized) {
      mediaRecorder.start(timeInterval);  // Add timeslice parameter here
      return;
    }
  
    navigator.mediaDevices.getUserMedia({ audio: true })
      .then(stream => {
        mediaRecorder = new MediaRecorder(stream);
        mediaRecorder.start(timeInterval);  // Add timeslice parameter here
        isMediaRecorderInitialized = true;
  
        mediaRecorder.ondataavailable = e => {
          audioBuffer.push(e.data);
        };

        // added code for silence detection
        const audioContext = new AudioContext();
        const audioStreamSource = audioContext.createMediaStreamSource(stream);
        const analyser = audioContext.createAnalyser();
        analyser.minDecibels = MIN_DECIBELS;
        audioStreamSource.connect(analyser);
        const bufferLength = analyser.frequencyBinCount;
        const domainData = new Uint8Array(bufferLength);
        const detectSound = () => {
          analyser.getByteFrequencyData(domainData);
          for (let i = 0; i < bufferLength; i++) {
            if (domainData[i] > 0) {
              soundDetected = true;              // Sound Detected, set the flag to true.
              appendMode=true;                   // When there is sound flip to continue appending to the soundfile as opposed to breaking in the middle.
              document.getElementById('appendMode').innerText = `appendMode:${appendMode}`;
              break;
            }else{
              soundDetected = false;             // When no sound is detected.
              appendMode=false;                  // You can break the file as set by the interval.
              document.getElementById('appendMode').innerText = `appendMode:${appendMode}`;
            }
          }
          window.requestAnimationFrame(detectSound);
        };
        window.requestAnimationFrame(detectSound);
        checkInterval = setInterval(() => {
          document.getElementById('soundDetected').innerText = soundDetected ? "Status: Sound Detected" : "Status: Silence Detected";
          soundDetected = false;  // Reset for the next second
        }, 50);
       
        mediaRecorder.onstop = e => {
          if (audioBuffer.length > 0) {
            if (appendMode){ 
              // if in append mode, keep adding to the audioBufffer and do not upload yet.
              if (audioBuffer.length >= chunkCount) {
                const selectedFormat = document.querySelector('input[name="fileFormat"]:checked').value; // New code
                const blob = new Blob(audioBuffer, { 'type' : `audio/${selectedFormat}` }); // flac or ogg 
                uploadToLinuxHost(blob);
                audioBuffer = [];

                appendMode=false;
                console.log("append Mode:", appendMode); // Debugging statement
                document.getElementById('appendMode').innerText = `appendMode:${appendMode}`;

              }
            } else {
              // else upload the code, we are not in the special case of continue don't upload.
              const selectedFormat = document.querySelector('input[name="fileFormat"]:checked').value; // New code
              const blob = new Blob(audioBuffer, { 'type' : `audio/${selectedFormat}` }); // flac or ogg 
              uploadToLinuxHost(blob);
              audioBuffer = [];
          
              // Save to IndexedDB
              const transaction = db.transaction(["audioChunks"], "readwrite");
              const objectStore = transaction.objectStore("audioChunks");
              const addRequest = objectStore.add(blob);
         
              addRequest.onsuccess = function(event) {
                const id = event.target.result;
                const fileName = generateFileName();
                updateUnifiedTable(fileName,null,id)
                sequenceNumber++;  // Increment sequence number here
              };
            }
  
          }
          if (shouldContinueRecording) {
            mediaRecorder.start();
          }
        };
  
        // Use user-defined timeInterval for the interval function
        intervalId = setInterval(() => {
          if (mediaRecorder.state === 'recording') {
            mediaRecorder.stop();
          }
        }, timeInterval); // Use user-defined time interval
        
      })
      .catch(err => console.error('getUserMedia error', err));
  };
  
  document.getElementById('stop').onclick = () => {
    shouldContinueRecording = false;
    if (mediaRecorder && mediaRecorder.state == 'recording') {
      mediaRecorder.stop();
    }
    if (intervalId) {
      clearInterval(intervalId);
    }
    isMediaRecorderInitialized = false;  
  };
  // Add this code to your script
  document.getElementById('toggle').onclick = () => {
    appendMode = !appendMode; // Toggle the appendMode
    console.log("append Mode:", appendMode); // Debugging statement
    document.getElementById('appendMode').innerText = `appendMode:${appendMode}`;
  };

  </script>


  <script>
  // Function to update the unified table
  function updateUnifiedTable(filename, transcribedText, audioBlobId) {
    // Debugging statement to log the function call and parameters
    console.log("updateUnifiedTable called with filename:", filename, "transcribedText", transcribedText, "audioBlobId:", audioBlobId);
  
    // Get the table body element
    const tableBody = document.getElementById('unifiedTableBody');
  
    // Check if a row with this filename already exists
    let existingRow = document.getElementById(filename);
  
    if (existingRow) {
      // Update the transcription cell
      existingRow.cells[2].innerHTML = transcribedText;
    } else {
      // Create a new row and cells
      const newRow = tableBody.insertRow();
      newRow.id = filename;  // Set the row ID to the filename
      const cell1 = newRow.insertCell(0);
      const cell2 = newRow.insertCell(1);
      const cell3 = newRow.insertCell(2);
  
      // Populate the cells
      cell1.innerHTML = filename;
  
      // Create a play button for audio playback
      const playButton = document.createElement("button");
      playButton.innerHTML = "Play";
      playButton.addEventListener("click", () => {
        // Fetch blob from IndexedDB and play
        const transaction = db.transaction(["audioChunks"]);
        const objectStore = transaction.objectStore("audioChunks");
        const getRequest = objectStore.get(audioBlobId);
  
        getRequest.onsuccess = function(event) {
          const audioBlob = event.target.result;
          const audioUrl = URL.createObjectURL(audioBlob);
          const audio = new Audio(audioUrl);
          audio.play();
        };
      });
  
      cell2.appendChild(playButton);
      cell3.innerHTML = transcribedText || "Transcribing...";  // If transcription is not yet available

      // Scroll to the bottom
      const unifiedTableContainer = document.getElementById('unifiedTableContainer');
      unifiedTableContainer.scrollTop = unifiedTableContainer.scrollHeight;

    }
  }

  // Helper function to create an audio play button
  function createAudioPlayButton(audioBlobId) {
    const playButton = document.createElement("button");
    playButton.innerHTML = "Play";
    playButton.addEventListener("click", () => {
      // Fetch blob from IndexedDB and play
      const transaction = db.transaction(["audioChunks"]);
      const objectStore = transaction.objectStore("audioChunks");
      const getRequest = objectStore.get(audioBlobId);
  
      getRequest.onsuccess = function(event) {
        const audioBlob = event.target.result;
        const audioUrl = URL.createObjectURL(audioBlob);
        const audio = new Audio(audioUrl);
        audio.play();
      };
    });
    return playButton;
  }
  </script>


  <script>
    <!-- Scroll to the bottom -->
    document.addEventListener("DOMContentLoaded", function() {
      window.scrollTo(0, document.body.scrollHeight);
     });
 </script> 
</body>
</html>







