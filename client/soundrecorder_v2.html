<!DOCTYPE html>
<html>
<head>
    <title>Audio Recorder with Buffer</title>
</head>
<body>

<!-- UI Elements for Controlling Recording -->
<button id="start">Start</button>
<button id="stop">Stop</button>
<br><br>
<label for="bufferInput">Buffer Length (ms):</label>
<input id="bufferInput" type="number" value="1000">
<br><br>
<label for="timeInterval">Sound Clip Length (ms):</label>
<input id="timeInterval" type="number" value="10000">
<br><br>
<label for="urlInput">Upload URL:</label>
<input id="urlInput" type="text" value="https://3llwzi00h3.execute-api.us-east-2.amazonaws.com/test/file-upload">
<br><br>
<label for="sequenceInput">Starting Sequence Number:</label>
<input id="sequenceInput" type="number" value="1">
<br><br>
<button id="update">Update</button>

<script>
// Initialize global variables
let chunks = [];  // Stores the current recording's audio data
let buffer = [];  // Stores the last chunk of the previous recording as a buffer
let mediaRecorder;  // MediaRecorder instance
let intervalId;  // ID returned by setInterval
let shouldContinueRecording = false;  // Flag to control recording state
let uploadURL = document.getElementById('urlInput').value;  // URL for uploading audio
let timeInterval = parseInt(document.getElementById('timeInterval').value);  // Duration of each recording
let sequenceNumber = parseInt(document.getElementById('sequenceInput').value);  // Starting sequence number
let bufferLength = parseInt(document.getElementById('bufferInput').value);  // Buffer length in milliseconds

// Generate a file name using the date and sequence number
const generateFileName = () => {
  // Code for generating filename remains the same
};

// Update settings based on user input
document.getElementById('update').onclick = () => {
  uploadURL = document.getElementById('urlInput').value;
  timeInterval = parseInt(document.getElementById('timeInterval').value);
  sequenceNumber = parseInt(document.getElementById('sequenceInput').value);
  bufferLength = parseInt(document.getElementById('bufferInput').value);
};

// Start recording audio
document.getElementById('start').onclick = () => {
  shouldContinueRecording = true;
  navigator.mediaDevices.getUserMedia({ audio: true })
  .then(stream => {
    mediaRecorder = new MediaRecorder(stream);
    mediaRecorder.start();

    // Store audio data chunks
    mediaRecorder.ondataavailable = e => {
      chunks.push(e.data);
    };

    // Stop recording and upload audio
    mediaRecorder.onstop = async () => {
      // Create a Blob containing buffer and new chunks
      const blob = new Blob([...buffer, ...chunks], { 'type': 'audio/flac' });

      // Update the buffer for the next audio chunk
      buffer = chunks.slice(-1);

      // Clear chunks for the next recording
      chunks = [];

      // Code for uploading the Blob remains the same
    };

    // Stop recording at regular intervals based on timeInterval and bufferLength
    intervalId = setInterval(() => {
      if (mediaRecorder.state == 'recording') {
        mediaRecorder.stop();
      }
    }, timeInterval + bufferLength);
  })
  .catch(err => console.error('getUserMedia error', err));
};

// Stop recording audio manually
document.getElementById('stop').onclick = () => {
  shouldContinueRecording = false;
  if (mediaRecorder && mediaRecorder.state == 'recording') {
    mediaRecorder.stop();
  }
  if (intervalId) {
    clearInterval(intervalId);
  }
};
</script>

</body>
</html>

